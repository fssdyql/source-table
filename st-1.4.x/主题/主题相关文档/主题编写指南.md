# 自定义主题编写指南 - 详细技术文档

## 1. 概述

### 1.1 什么是自定义主题？
自定义主题是插件列表管理器的核心扩展功能，它允许用户创建完全自定义的导出页面模板。每个主题都是一个完整的HTML文件，系统会将当前的数据注入到模板中，生成最终的静态页面。

### 1.2 工作原理
系统采用**变量替换机制**，将动态数据注入到静态HTML模板中：
- **编译时**：将数据对象序列化为JSON字符串
- **替换时**：将模板中的 `{{变量}}` 替换为对应的值
- **生成时**：生成独立的HTML文件，包含完整的CSS、JavaScript和数据

### 1.3 核心优势
- **完全控制**：可以完全控制最终页面的布局、样式和交互
- **可移植性**：导出的HTML文件完全独立，无需后端支持
- **灵活性**：支持不同标签页的差异化展示
- **复用性**：主题可以保存、导出和分享

## 2. 模板变量详解

### 2.1 `{{DATA}}` - 数据对象
**类型**: JavaScript对象（JSON格式）
**作用**: 包含所有插件数据和配置信息
**使用方式**: 必须通过 `JSON.parse()` 或直接赋值解析

```javascript
// 标准使用方式
const data = {{DATA}};
// 或简写形式（适用于现代浏览器）
const { items, config, customTabs } = {{DATA}};
```

**数据结构**：
```javascript
{
  config: {
    showMF: boolean,      // 是否显示Music Free标签页
    showLY: boolean       // 是否显示澜音标签页
  },
  customTabs: string[],   // 自定义标签页名称数组
  items: [               // 插件数据数组
    {
      id: number,         // 唯一标识符（时间戳）
      tab: string,        // 所属标签页（'LX'、'Music Free'、'澜音'或自定义）
      name: string,       // 文件名（包含扩展名）
      ver: string,        // 版本号（可选）
      quality: string,    // 音质标识（128k、320k、flac等）
      note: string,       // 备注信息
      file: {             // 文件数据对象
        content: string,  // Base64编码的文件内容（data:URL格式）
        size: number      // 文件大小（字节）
      },
      links: [            // 相关链接数组
        {
          text: string,   // 链接显示文本
          url: string     // 链接地址
        }
      ],
      dlLink: string,     // 直链下载地址（可选）
      keyConfig: {        // Key配置（仅LX标签页有效）
        enableUrl: boolean, // 是否启用在线Key导入
        url: string,      // 在线导入API地址
        enableVar: boolean, // 是否启用本地变量替换
        var: string       // 变量名（默认为'API_KEY'）
      }
    }
  ]
}
```

### 2.2 `{{DATE}}` - 导出日期
**类型**: 字符串
**格式**: `YYYY-MM-DD`
**示例**: `2024-12-26`
**用途**: 在页面中显示导出时间

```html
<!-- 在HTML中使用 -->
<div class="export-date">导出时间：{{DATE}}</div>
```

### 2.3 `{{TITLE}}` - 页面标题
**类型**: 字符串
**默认值**: `"插件列表"`
**用途**: 设置页面的 `<title>` 和主标题

```html
<title>{{TITLE}} - 插件列表</title>
<h1>{{TITLE}}</h1>
```

## 3. 数据结构深度解析

### 3.1 配置对象 (config)
```javascript
{
  showMF: false,    // Music Free标签页开关
  showLY: false     // 澜音标签页开关
}
```

**使用建议**：
- 根据 `showMF` 和 `showLY` 决定显示哪些标签页
- 可以创建标签页切换逻辑

### 3.2 插件对象 (items) 详细字段

#### 3.2.1 基础字段
```javascript
{
  id: 1703548800000,    // 唯一ID（推荐用于DOM id属性）
  tab: 'LX',            // 标签页分类
  name: 'Spotify.js',   // 完整文件名
  ver: '1.2.3',         // 语义化版本号（可为空）
  quality: 'flac',      // 音质标识
  note: '支持高解析度音频' // 描述性备注
}
```

#### 3.2.2 文件数据 (file)
```javascript
file: {
  content: 'data:application/javascript;base64,...', // Base64编码
  size: 20480  // 单位：字节
}
```

**重要信息**：
- `file.content` 可直接用于 `a.href` 进行下载
- 使用 `atob()` 解码Base64内容
- 文件大小可用于显示和筛选

#### 3.2.3 链接数据 (links)
```javascript
links: [
  { text: '官网', url: 'https://example.com' },
  { text: '文档', url: 'https://docs.example.com' },
  { text: 'GitHub', url: 'https://github.com/example' }
]
```

#### 3.2.4 Key配置 (keyConfig)
```javascript
keyConfig: {
  enableUrl: true,
  url: 'https://api.example.com/import?key=',
  enableVar: true,
  var: 'API_KEY'
}
```

## 4. 详细步骤与代码示例

### 4.1 步骤1：选择合适的起点

#### 4.1.1 默认主题
**特点**：
- 功能完整，包含标签页切换
- 支持直链下载和Key配置
- 响应式设计

**适用场景**：
- 需要完整功能
- 多标签页管理
- 复杂的交互需求

#### 4.1.2 极简主题
**特点**：
- 结构简单，易于修改
- 代码量少
- 基础功能

**适用场景**：
- 快速原型
- 轻量级需求
- 学习模板结构

#### 4.1.3 空主题
**特点**：
- 最小化结构
- 注释指导
- 自由度高

**适用场景**：
- 从零开始构建
- 高度定制需求
- 教学演示

#### 4.1.4 导入外部HTML
**步骤**：
1. 准备一个完整的HTML文件
2. 在需要插入数据的位置添加 `{{DATA}}`
3. 编写JavaScript解析逻辑
4. 导入到主题系统

### 4.2 步骤2：理解数据结构

#### 4.2.1 数据访问最佳实践
```javascript
// 安全的数据访问函数
function getData() {
  try {
    const rawData = {{DATA}};
    if (typeof rawData === 'string') {
      return JSON.parse(rawData);
    }
    return rawData;
  } catch (error) {
    console.error('数据解析失败:', error);
    return { config: {}, customTabs: [], items: [] };
  }
}

// 获取当前标签页数据
function getCurrentTabData(tabName = 'LX') {
  const data = getData();
  return {
    config: data.config || {},
    tabs: ['LX'].concat(
      data.config?.showMF ? ['Music Free'] : [],
      data.config?.showLY ? ['澜音'] : [],
      data.customTabs || []
    ),
    items: (data.items || []).filter(item => 
      (item.tab || 'LX') === tabName
    ),
    totalCount: (data.items || []).length
  };
}
```

#### 4.2.2 数据验证与默认值
```javascript
function validateItem(item) {
  return {
    id: item.id || Date.now(),
    tab: item.tab || 'LX',
    name: item.name || '未命名文件.js',
    ver: item.ver || '1.0.0',
    quality: item.quality || '未知',
    note: item.note || '',
    file: item.file || null,
    links: item.links || [],
    dlLink: item.dlLink || '',
    keyConfig: item.keyConfig || {
      enableUrl: false,
      url: '',
      enableVar: false,
      var: 'API_KEY'
    }
  };
}
```

### 4.3 步骤3：编写JavaScript逻辑

#### 4.3.1 基础数据解析
```javascript
// 安全的数据解析方案
function initializeApp() {
  // 1. 解析全局数据
  window.appData = (function() {
    const dataString = {{DATA}};
    try {
      return typeof dataString === 'string' 
        ? JSON.parse(dataString) 
        : dataString;
    } catch (e) {
      console.error('数据解析失败:', e);
      return { items: [], config: {}, customTabs: [] };
    }
  })();
  
  // 2. 初始化应用状态
  window.appState = {
    currentTab: 'LX',
    searchQuery: '',
    sortBy: 'name',
    sortOrder: 'asc'
  };
  
  // 3. 渲染页面
  renderTabs();
  renderContent();
}

// 按标签页筛选数据
function getItemsByTab(tabName) {
  return appData.items.filter(item => {
    const itemTab = item.tab || 'LX';
    return itemTab === tabName;
  });
}

// 搜索功能
function searchItems(query) {
  const currentItems = getItemsByTab(appState.currentTab);
  if (!query) return currentItems;
  
  const keywords = query.toLowerCase().split(' ');
  return currentItems.filter(item => {
    const searchableText = [
      item.name,
      item.note,
      item.ver,
      item.quality,
      ...(item.links || []).map(link => link.text)
    ].join(' ').toLowerCase();
    
    return keywords.every(keyword => 
      searchableText.includes(keyword)
    );
  });
}
```

#### 4.3.2 文件处理函数
```javascript
// 下载文件（基础版）
function downloadFile(itemId) {
  const item = appData.items.find(x => x.id === itemId);
  if (!item || !item.file) {
    alert('文件不存在');
    return;
  }
  
  try {
    const a = document.createElement('a');
    a.href = item.file.content;
    a.download = item.name;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
  } catch (error) {
    console.error('下载失败:', error);
    alert('下载失败：' + error.message);
  }
}

// 高级文件下载（支持大文件）
function downloadFileWithProgress(itemId) {
  const item = appData.items.find(x => x.id === itemId);
  if (!item || !item.file) return;
  
  // 显示进度
  const progress = document.createElement('div');
  progress.className = 'download-progress';
  progress.innerHTML = `正在下载 ${item.name}...`;
  document.body.appendChild(progress);
  
  setTimeout(() => {
    const a = document.createElement('a');
    a.href = item.file.content;
    a.download = item.name;
    a.click();
    progress.remove();
  }, 100);
}

// Base64解码函数
function decodeBase64Data(dataURI) {
  // 从 data:application/javascript;base64,SGVsbG8= 中提取Base64部分
  const base64Data = dataURI.split(',')[1];
  try {
    return atob(base64Data);
  } catch (error) {
    console.error('Base64解码失败:', error);
    return '';
  }
}

// 文件大小格式化
function formatFileSize(bytes) {
  if (bytes === 0) return '0 B';
  const k = 1024;
  const sizes = ['B', 'KB', 'MB', 'GB'];
  const i = Math.floor(Math.log(bytes) / Math.log(k));
  return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
}
```

#### 4.3.3 Key配置处理
```javascript
// 在线Key导入
function importWithKeyOnline(itemId) {
  const item = appData.items.find(x => x.id === itemId);
  if (!item?.keyConfig?.enableUrl) return;
  
  const key = prompt(`请输入Key以导入 ${item.name}:`, '');
  if (key && item.keyConfig.url) {
    window.open(item.keyConfig.url + encodeURIComponent(key), '_blank');
  }
}

// 本地Key替换
function generateFileWithKey(itemId) {
  const item = appData.items.find(x => x.id === itemId);
  if (!item?.keyConfig?.enableVar) {
    alert('此文件不支持本地Key导入');
    return;
  }
  
  const key = prompt(`请输入Key（将替换变量 ${item.keyConfig.var}）:`, '');
  if (!key) return;
  
  try {
    // 解码Base64
    const base64Data = item.file.content.split(',')[1];
    const rawContent = atob(base64Data);
    
    // 替换变量
    const variableName = item.keyConfig.var;
    const regex = new RegExp(`(const|var|let)\\s+${variableName}\\s*=\\s*['"][^'"]*['"]`, 'g');
    
    if (!regex.test(rawContent)) {
      alert(`未找到变量: ${variableName}`);
      return;
    }
    
    const newContent = rawContent.replace(
      regex,
      `$1 ${variableName} = "${key.replace(/"/g, '\\"')}"`
    );
    
    // 创建下载
    const blob = new Blob([newContent], { type: 'text/javascript' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = item.name;
    a.click();
    
    // 清理URL对象
    setTimeout(() => URL.revokeObjectURL(url), 100);
  } catch (error) {
    console.error('生成文件失败:', error);
    alert('生成失败: ' + error.message);
  }
}
```

### 4.4 步骤4：自定义样式与布局

#### 4.4.1 CSS架构建议
```css
/* 基础变量系统 */
:root {
  /* 颜色系统 */
  --primary-color: #2563eb;
  --secondary-color: #64748b;
  --success-color: #10b981;
  --danger-color: #ef4444;
  --warning-color: #f59e0b;
  
  /* 间距系统 */
  --spacing-xs: 4px;
  --spacing-sm: 8px;
  --spacing-md: 16px;
  --spacing-lg: 24px;
  --spacing-xl: 32px;
  
  /* 字体系统 */
  --font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
  --font-size-sm: 12px;
  --font-size-base: 14px;
  --font-size-lg: 16px;
  --font-size-xl: 18px;
  
  /* 圆角系统 */
  --border-radius-sm: 4px;
  --border-radius-md: 8px;
  --border-radius-lg: 12px;
  
  /* 阴影系统 */
  --shadow-sm: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
  --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
  --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
}

/* 暗色主题 */
@media (prefers-color-scheme: dark) {
  :root {
    --primary-color: #3b82f6;
    --secondary-color: #94a3b8;
    --background-color: #1e293b;
    --text-color: #f1f5f9;
  }
}

/* 响应式布局 */
.container {
  max-width: 1200px;
  margin: 0 auto;
  padding: var(--spacing-lg);
}

/* 网格系统 */
.plugin-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
  gap: var(--spacing-md);
  margin-top: var(--spacing-lg);
}

@media (max-width: 768px) {
  .plugin-grid {
    grid-template-columns: 1fr;
  }
  
  .container {
    padding: var(--spacing-md);
  }
}
```

#### 4.4.2 动画效果
```css
/* 悬停动画 */
.plugin-card {
  transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
}

.plugin-card:hover {
  transform: translateY(-4px);
  box-shadow: var(--shadow-lg);
}

/* 加载动画 */
@keyframes fadeIn {
  from { opacity: 0; transform: translateY(10px); }
  to { opacity: 1; transform: translateY(0); }
}

.plugin-item {
  animation: fadeIn 0.3s ease-out forwards;
}

/* 按钮动画 */
.btn {
  position: relative;
  overflow: hidden;
}

.btn:active::after {
  content: '';
  position: absolute;
  top: 50%;
  left: 50%;
  width: 5px;
  height: 5px;
  background: rgba(255, 255, 255, 0.5);
  border-radius: 50%;
  transform: translate(-50%, -50%) scale(0);
  animation: ripple 0.6s linear;
}

@keyframes ripple {
  to {
    transform: translate(-50%, -50%) scale(20);
    opacity: 0;
  }
}
```

#### 4.4.3 HTML结构示例
```html
<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>{{TITLE}}</title>
  <style>
    /* CSS样式放在这里 */
  </style>
</head>
<body>
  <div class="app-container">
    <!-- 头部区域 -->
    <header class="app-header">
      <h1>{{TITLE}}</h1>
      <div class="meta-info">
        导出时间：{{DATE}} | 共 {{COUNT}} 个插件
      </div>
    </header>
    
    <!-- 标签页导航 -->
    <nav class="tab-navigation" id="tabNav"></nav>
    
    <!-- 工具栏 -->
    <div class="toolbar">
      <input type="search" placeholder="搜索插件..." class="search-input">
      <div class="view-controls">
        <button class="view-btn active" data-view="grid">网格</button>
        <button class="view-btn" data-view="list">列表</button>
      </div>
    </div>
    
    <!-- 内容区域 -->
    <main class="content-area" id="contentArea">
      <!-- 动态内容 -->
    </main>
    
    <!-- 页脚 -->
    <footer class="app-footer">
      <p>由插件列表管理器生成 | {{DATE}}</p>
    </footer>
  </div>
  
  <script>
    // JavaScript代码放在这里
    // 注意：{{DATA}} 变量必须包含在JavaScript代码中
    const appData = {{DATA}};
    
    // 初始化应用
    function init() {
      // 应用逻辑
    }
    
    // 页面加载完成后执行
    window.addEventListener('DOMContentLoaded', init);
  </script>
</body>
</html>
```

## 5. 高级技巧与完整示例

### 5.1 按音质分组显示
```javascript
function groupByQuality(items) {
  const groups = {};
  
  items.forEach(item => {
    const quality = item.quality || '未知音质';
    if (!groups[quality]) {
      groups[quality] = {
        name: quality,
        items: [],
        count: 0
      };
    }
    groups[quality].items.push(item);
    groups[quality].count++;
  });
  
  // 转换为数组并按数量排序
  return Object.values(groups).sort((a, b) => b.count - a.count);
}

// 渲染分组界面
function renderGroupedView(groups) {
  let html = '';
  
  groups.forEach(group => {
    html += `
      <div class="quality-group">
        <h3 class="group-title">
          ${group.name} <span class="badge">${group.count}</span>
        </h3>
        <div class="group-items">
          ${group.items.map(item => renderPluginItem(item)).join('')}
        </div>
      </div>
    `;
  });
  
  return html;
}
```

### 5.2 完整的搜索功能实现
```javascript
class PluginSearch {
  constructor(items) {
    this.items = items;
    this.index = this.buildIndex();
  }
  
  // 构建搜索索引
  buildIndex() {
    return this.items.map(item => ({
      id: item.id,
      name: item.name.toLowerCase(),
      note: item.note.toLowerCase(),
      quality: item.quality.toLowerCase(),
      ver: item.ver.toLowerCase(),
      tags: this.extractTags(item)
    }));
  }
  
  // 提取标签
  extractTags(item) {
    const tags = [];
    
    // 从文件名提取
    const nameParts = item.name.replace('.js', '').split(/[_-]/);
    tags.push(...nameParts.map(p => p.toLowerCase()));
    
    // 从备注提取
    if (item.note) {
      const noteWords = item.note.split(/[\s,，。]+/);
      tags.push(...noteWords.filter(w => w.length > 1).map(w => w.toLowerCase()));
    }
    
    return [...new Set(tags)]; // 去重
  }
  
  // 搜索功能
  search(query, filters = {}) {
    if (!query.trim()) {
      return this.applyFilters(this.items, filters);
    }
    
    const keywords = query.toLowerCase().split(/\s+/);
    const results = [];
    
    this.index.forEach((entry, index) => {
      let score = 0;
      
      // 名称匹配（最高权重）
      if (entry.name.includes(keywords[0])) {
        score += 100;
      }
      
      // 备注匹配
      keywords.forEach(keyword => {
        if (entry.note.includes(keyword)) score += 10;
        if (entry.tags.includes(keyword)) score += 5;
      });
      
      // 完全匹配文件名
      if (entry.name === keywords[0].toLowerCase()) {
        score += 50;
      }
      
      if (score > 0) {
        results.push({
          item: this.items[index],
          score: score
        });
      }
    });
    
    // 按分数排序
    results.sort((a, b) => b.score - a.score);
    
    // 应用过滤器
    const filteredItems = results.map(r => r.item);
    return this.applyFilters(filteredItems, filters);
  }
  
  // 应用过滤器
  applyFilters(items, filters) {
    return items.filter(item => {
      if (filters.quality && item.quality !== filters.quality) return false;
      if (filters.hasFile && !item.file) return false;
      if (filters.hasLinks && (!item.links || item.links.length === 0)) return false;
      if (filters.tab && item.tab !== filters.tab) return false;
      return true;
    });
  }
}
```

### 5.3 暗色模式完整实现
```javascript
// 暗色模式管理器
class DarkModeManager {
  constructor() {
    this.isDark = false;
    this.init();
  }
  
  init() {
    // 检查系统偏好
    const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
    
    // 检查本地存储
    const savedMode = localStorage.getItem('darkMode');
    
    // 确定初始模式
    if (savedMode !== null) {
      this.isDark = savedMode === 'dark';
    } else {
      this.isDark = prefersDark;
    }
    
    this.apply();
    
    // 监听系统主题变化
    window.matchMedia('(prefers-color-scheme: dark)')
      .addEventListener('change', (e) => {
        if (localStorage.getItem('darkMode') === null) {
          this.isDark = e.matches;
          this.apply();
        }
      });
  }
  
  toggle() {
    this.isDark = !this.isDark;
    this.apply();
    localStorage.setItem('darkMode', this.isDark ? 'dark' : 'light');
  }
  
  apply() {
    if (this.isDark) {
      document.documentElement.classList.add('dark');
    } else {
      document.documentElement.classList.remove('dark');
    }
  }
}

// 对应的CSS
<style>
  :root {
    --bg-color: #ffffff;
    --text-color: #334155;
    --card-bg: #f8fafc;
    --border-color: #e2e8f0;
    --primary-color: #2563eb;
  }
  
  .dark {
    --bg-color: #0f172a;
    --text-color: #f1f5f9;
    --card-bg: #1e293b;
    --border-color: #334155;
    --primary-color: #3b82f6;
  }
  
  body {
    background-color: var(--bg-color);
    color: var(--text-color);
    transition: background-color 0.3s, color 0.3s;
  }
  
  .plugin-card {
    background: var(--card-bg);
    border: 1px solid var(--border-color);
    color: var(--text-color);
    transition: all 0.3s;
  }
</style>
```

## 6. 最佳实践与注意事项

### 6.1 性能优化
1. **避免全局搜索**：只在当前标签页内搜索
2. **虚拟滚动**：当插件数量过多时（>100个）
3. **懒加载**：图片和大型资源
4. **防抖搜索**：搜索框添加防抖处理

```javascript
// 防抖函数实现
function debounce(func, wait) {
  let timeout;
  return function executedFunction(...args) {
    const later = () => {
      clearTimeout(timeout);
      func(...args);
    };
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
  };
}

// 使用防抖
const searchInput = document.getElementById('search');
searchInput.addEventListener('input', debounce(function(e) {
  performSearch(e.target.value);
}, 300));
```

### 6.2 兼容性考虑
1. **ES6+特性**：确保代码在主流浏览器中可用
2. **CSS Grid/Flexbox**：提供fallback方案
3. **文件API**：处理Base64解码的兼容性
4. **移动端适配**：确保在小屏幕上可用

### 6.3 安全性
1. **XSS防护**：对用户输入进行转义
2. **URL验证**：验证链接的有效性
3. **数据验证**：验证导入的数据结构
4. **CSP考虑**：避免内联事件处理器

### 6.4 调试技巧
```javascript
// 开发模式调试
if (window.location.href.includes('debug=1')) {
  console.log('应用数据:', appData);
  console.log('插件数量:', appData.items.length);
  console.log('标签页配置:', appData.config);
}

// 性能监控
console.time('渲染耗时');
renderContent();
console.timeEnd('渲染耗时');
```

### 6.5 错误处理
```javascript
// 全局错误处理
window.addEventListener('error', function(event) {
  console.error('全局错误:', event.error);
  
  // 显示用户友好的错误信息
  if (document.getElementById('error-container')) {
    document.getElementById('error-container').innerHTML = `
      <div class="error-message">
        <h3>出现错误</h3>
        <p>${event.error.message}</p>
        <button onclick="location.reload()">刷新页面</button>
      </div>
    `;
  }
});

// 数据验证
function validateDataStructure(data) {
  const requiredFields = ['items', 'config', 'customTabs'];
  const missingFields = requiredFields.filter(field => !data[field]);
  
  if (missingFields.length > 0) {
    throw new Error(`数据格式错误，缺少字段: ${missingFields.join(', ')}`);
  }
  
  if (!Array.isArray(data.items)) {
    throw new Error('items必须是数组');
  }
}
```

## 7. 模板示例集合

### 7.1 卡片视图模板
```html
<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>{{TITLE}}</title>
  <style>
    .card-view { display: grid; grid-template-columns: repeat(auto-fill, minmax(300px, 1fr)); gap: 20px; }
    .plugin-card { border: 1px solid #e2e8f0; border-radius: 12px; padding: 20px; background: #fff; }
  </style>
</head>
<body>
  <div id="app">
    <!-- 动态内容 -->
  </div>
  <script>
    const data = {{DATA}};
    // 渲染逻辑
  </script>
</body>
</html>
```

### 7.2 表格视图模板
```html
<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>{{TITLE}}</title>
  <style>
    .table-view { width: 100%; border-collapse: collapse; }
    .table-view th { background: #f8fafc; padding: 12px; text-align: left; }
  </style>
</head>
<body>
  <table class="table-view">
    <!-- 动态内容 -->
  </table>
  <script>
    const data = {{DATA}};
    // 渲染逻辑
  </script>
</body>
</html>
```

## 8. 故障排除

### 常见问题及解决方案

| 问题 | 可能原因 | 解决方案 |
|------|----------|----------|
| 页面空白 | {{DATA}} 替换失败 | 检查模板语法，确保使用正确的变量 |
| 下载失败 | Base64数据格式错误 | 验证文件数据的完整性 |
| 搜索无结果 | 数据解析错误 | 使用 try-catch 包装数据解析逻辑 |
| 样式错乱 | CSS冲突 | 使用CSS命名空间或重置样式 |
| 页面卡顿 | 插件数量过多 | 实现虚拟滚动或分页加载 |

### 调试检查清单
1. [ ] {{DATA}} 变量正确替换
2. [ ] JavaScript语法无误
3. [ ] CSS选择器不冲突
4. [ ] 文件下载功能正常
5. [ ] 移动端适配良好
6. [ ] 浏览器兼容性测试
7. [ ] 性能监控正常

---

通过这份详细的技术文档，你应该能够：
1. 理解自定义主题的完整工作原理
2. 掌握所有模板变量的使用方法
3. 熟练编写数据处理逻辑
4. 创建美观且功能完整的主题
5. 解决开发过程中遇到的各种问题

记住，主题系统的核心思想是**灵活性**和**可扩展性**。你可以根据自己的需求创建任意复杂度的主题，从最简单的列表展示到功能丰富的管理界面。